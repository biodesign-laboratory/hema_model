# # Clocked thermostat
using ReachabilityAnalysis, ModelingToolkit, Plots

# Extract rates into individual variables
w = 0.0005
P_crit = 7000
A_crit = 1000
t_half_leukocytes = 7
t_half_P = 4.1375
t_half_A = 7
t_double_P = 15
gamma = 0.0000001
S_a = 1
S_n = 1
N_inf = 20000000
S_PQ = 0.33
S_PH = 0.01
S_PS = 0.02
S_AS = 0.04
S_AH = 0.01
S_AU = 0.33
theta_ps = 10000000
theta_ar = 10000000
theta_AS = 10000000
theta_UP = 10000000
Immune_start = 500
Active_start = 500
Immune_crit = 2500
Active_crit = 2500
y = 2500
d_s = 1/70
d_p = 1/4
d_a = 1/4
d_q = 1/4
d_u = 0.05
g_n = 0.2
K_PS = 0.7
K_AQ = 0.7
K_PU = 0.7
K_AS = 0.7
k_nq = 0.85
k_ns = 0.2
k_tn = 0.33
H = 1000
N_func = 0.0
P = 600
A = 1160
T = 7000
a = 0.00
b = 1
e = 0.00
E_star = 1
H_0 = 1000
N_0 = 0.0
P_0 = 600
A_0 = 1160
T_0 = 7000
a_0 = 0.00
b_0 = 1
e_0 = 0.00
E_star_0 = 1

# Calculate nodes based on the extracted variables
Q = a * T
S = b * T
U = e * T

const t1 = 7000
const t2 = 0
const t3 = 0
normal_vector = [1.0, 0.0, 0.0]
offset = t1


const var′ = @variables t t′

#3 states, 3 dimensions (H N P)

@taylorize function immune_under!(du, u, p, time)
    H, N = u

    E = 1
    Renewal = (0.35 * ((P + S_n * N - S_a * A)/P_crit)) * H
    D = (0.35 * ((P + S_n * N - S_a * A)/P_crit)) * H
    #D_P = d_p * P

    # H'
    du[1] = E * (Renewal + H) - D

    # N'
    du[2] = g_n * N - (k_nq * Q + k_ns * S) * (1-1/N_inf)

    #P'
    #du[3] = (S_PS * S + S_PQ * Q + S_PH * H) - D_P

    return du
end

@taylorize function immune_over!(du, u, p, time)
    H, N = u

    E =  E = 2 - (2/(1+(-1 * y * (P + S_n * N - S_a * A - P_crit))))
    Renewal = 0.35 * H
    D = 0.35 * H
    #D_P = d_p * P


    # H'
    du[1] = E * (Renewal + H) - D

    # N'
    du[2] = g_n * N - (k_nq * Q + k_ns * S) * (1-1/N_inf)

    #P'
    #du[3] = (S_PS * S + S_PQ * Q + S_PH * H) - D_P

    return du
end

@taylorize function immune_zero!(du, u, p, time)
    H, N = u

    E = 1
    Renewal = 0
    D = 0
    #D_P = d_p * P


    # H'
    du[1] = E * (Renewal + H) - D

    # N'
    du[2] = g_n * N - (k_nq * Q + k_ns * S) * (1-1/N_inf)

    # P'
    #du[3] = (S_PS * S + S_PQ * Q + S_PH * H) - D_P

    return du
end

function immune_over′()
    invariant = HalfSpace(t <= t1, var′)
    @system(x' = immune_over!(x), dim:2, x ∈ invariant)
end

function immune_under′()
    invariant = HalfSpace(t <= t2, var′)
    @system(x' = immune_under!(x), dim:2, x ∈ invariant)
end

function immune_zero′()
    invariant = HalfSpace(t >= t3, var′)
    @system(x' = immune_zero!(x), dim:2, x ∈ invariant)
end

function thermostat_hybrid′()
    automaton = GraphAutomaton(3)
    add_transition!(automaton, 1, 2, 2)
    add_transition!(automaton, 2, 1, 3)
    add_transition!(automaton, 2, 3, 1)

    mode1 = immune_over′()
    mode2 = immune_under′()
    mode3 = immune_zero′()
    modes = [mode1, mode2, mode3]

    ## transition 2 -> 3
    guard = HalfSpace(t >= t1, var′)
    trans1 = ConstrainedIdentityMap(1, guard)
    ## transition 1 -> 2
    guard = HalfSpace(t >= t2, var′)
    trans2 = ConstrainedIdentityMap(1, guard)
    ## transition 2 -> 1
    guard = HalfSpace(t <= t3, var′)
    trans3 = ConstrainedIdentityMap(1, guard)
    resetmaps = [trans1, trans2, trans3]

    return HybridSystems.HybridSystem(automaton, modes, resetmaps, [AutonomousSwitching()])
end

function model(X0)
    H = thermostat_hybrid′()
    return IVP(H, X0)
end

# ## References
X0 = Hyperrectangle(; low=[500.0, 0.0], high=[1000.0, 2000.0])
prob = model(X0) # initial-value problem

sol = solve(prob, T=5.0); # solve it using default options

idx_approaching = findall(x -> x == 1, location.(sol))
idx_attempt = findall(x -> x == 2, location.(sol))
idx_aborting = findall(x -> x == 3, location.(sol))

fig = plot()

plot!(fig, sol[idx_approaching[1]]; vars=(0, 1), lw=0.0, color=:lightgreen, alpha=1,
      lab="zero HSPC")
for k in idx_approaching[2:end]
    plot!(fig, sol[k]; vars=(0, 1), lw=0.0, color=:lightgreen, alpha=1)
end

plot!(fig, sol[idx_attempt[1]]; vars=(0, 1), lw=0.0, color=:red, alpha=1, lab="under HSPC")
for k in idx_attempt[2:end]
    plot!(fig, sol[k]; vars=(0, 1), lw=0.0, color=:red, alpha=1)
end

plot!(fig, sol[idx_aborting[1]]; vars=(0, 1), lw=0.0, color=:cyan, alpha=1, lab="over HSPC")
for k in idx_aborting[2:end]
    plot!(fig, sol[k]; vars=(0, 1), lw=0.0, color=:cyan, alpha=1)
end

plot!(fig, sol[idx_approaching[1]]; vars=(0, 2), lw=0.0, color=:blue, alpha=1,
      lab="zero Pathogens")
for k in idx_approaching[2:end]
    plot!(fig, sol[k]; vars=(0, 2), lw=0.0, color=:blue, alpha=1)
end

plot!(fig, sol[idx_attempt[1]]; vars=(0, 2), lw=0.0, color=:green, alpha=1, lab="under Pathogens")
for k in idx_attempt[2:end]
    plot!(fig, sol[k]; vars=(0, 2), lw=0.0, color=:green, alpha=1)
end

plot!(fig, sol[idx_aborting[1]]; vars=(0, 2), lw=0.0, color=:purple, alpha=1, lab="over Pathogens")
for k in idx_aborting[2:end]
    plot!(fig, sol[k]; vars=(0, 2), lw=0.0, color=:purple, alpha=1)
end

fig

#plot(sol, vars=(0, 2)) # plot the solution